<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Christmas Showroom: Pro Ratio</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Times New Roman', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
        
        .header { 
            position: absolute; top: 20px; width: 100%; text-align: center; 
            color: #d4af37; font-size: 2rem; letter-spacing: 5px; text-shadow: 0 0 30px #d4af37, 0 0 10px #ffffff;
            font-weight: bold; pointer-events: none;
        }

        #input-video { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: -1; }
        
        #loading { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-size: 1.5rem; transition: opacity 0.5s; z-index: 50; text-shadow: 0 0 10px black;
        }

        .arrow {
            position: absolute; top: 50%; transform: translateY(-50%);
            font-size: 6rem; color: rgba(255, 215, 0, 0.5); cursor: pointer;
            pointer-events: auto; user-select: none; transition: 0.3s;
            display: none; filter: drop-shadow(0 0 15px #d4af37);
        }
        .arrow:hover, .arrow.active { color: #fff; scale: 1.2; filter: drop-shadow(0 0 30px #d4af37); }
        #prev-btn { left: 30px; }
        #next-btn { right: 30px; }

        #gesture-hint {
            position: absolute; bottom: 20px; right: 20px;
            color: rgba(255,255,255,0.5); font-size: 14px; text-align: right;
            line-height: 1.6; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading">Loading Gold & Geometry...</div>
    <div class="header">SHOW ROOM</div>
    
    <div id="ui-layer">
        <div id="prev-btn" class="arrow">‚Äπ</div>
        <div id="next-btn" class="arrow">‚Ä∫</div>
        <div id="gesture-hint">
            ‚úä Fist: Tree (Reset)<br>
            üñê Palm: Explode / Wave<br>
            ‚òù Index: Select Image
        </div>
    </div>

    <video id="input-video"></video>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        // --- CONFIG ---
        // ËØ∑Á°Æ‰øùÂõæÁâáÊï∞ÈáèÊ≠£Á°Æ
        const IMAGE_URLS = Array.from({ length: 7 }, (_, i) => `./${(i + 1).toString().padStart(2, '0')}.jpg`);

        const PARTICLE_COUNT = 3500;
        const ORNAMENT_COUNT = 250;
        const TREE_HEIGHT = 45;
        const TREE_RADIUS = 18;

        const STATE = {
            current: 'TREE', 
            handX: 0.5, handY: 0.5,
            galleryIndex: 0,
            lastHandX: 0.5, lastWaveTime: 0
        };

        // --- SCENE ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.025); // Á®çÂæÆÂä†Èáç‰∏ÄÁÇπÈõæÔºåÂ¢ûÂº∫ÊôØÊ∑±ÊÑü

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const CAM_DEFAULT_POS = new THREE.Vector3(0, 10, 65);
        camera.position.copy(CAM_DEFAULT_POS);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // Environment for Reflection
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        
        // Tone Mapping: Ë∞ÉËäÇÊõùÂÖâÔºåÂπ≥Ë°°‰∫ÆÈÉ®ÂíåÊöóÈÉ®
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8; 
        container.appendChild(renderer.domElement);

        // --- GLOW EFFECT (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        
        // Ê†∏ÂøÉÂèÇÊï∞Ë∞ÉÊï¥Ôºö
        // Threshold (0.15): ÂÖÅËÆ∏Â§ßÈÉ®ÂàÜÂèëÂÖâÁâ©‰Ωì‰∫ßÁîüÂÖâÊôï
        // Strength (2.2): ÂÖâÊôïÂº∫Â∫¶ÂæàÈ´ò
        // Radius (0.6): Êâ©Êï£ËåÉÂõ¥ÈÄÇ‰∏≠
        bloomPass.threshold = 0.15; 
        bloomPass.strength = 2.2; 
        bloomPass.radius = 0.6;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.02); // ÈùûÂ∏∏ÊöóÁöÑÁéØÂ¢ÉÂÖâ
        scene.add(ambientLight);
        const mainLight = new THREE.PointLight(0xffd700, 3, 100);
        mainLight.position.set(10, 20, 20);
        scene.add(mainLight);

        // --- OBJECTS ---
        const dummy = new THREE.Object3D();
        const _color = new THREE.Color();

        // 1. Glowing Particles (High Emissive)
        const particleGeo = new THREE.SphereGeometry(0.12, 4, 4);
        const particleMat = new THREE.MeshStandardMaterial({ 
            color: 0x000000, 
            emissive: 0xffd700, // ÈáëËâ≤Ëá™ÂèëÂÖâ
            emissiveIntensity: 4.0, // Âº∫Â∫¶4.0 -> ËøúË∂ÖÈòàÂÄº0.15Ôºå‰∫ßÁîüÂº∫ÁÉàÂÖâÊôï
            roughness: 0.4,
            metalness: 0.8
        });
        const particles = new THREE.InstancedMesh(particleGeo, particleMat, PARTICLE_COUNT);
        const particleData = [];

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const y = Math.random() * TREE_HEIGHT;
            const r = (1 - y / TREE_HEIGHT) * TREE_RADIUS;
            const angle = y * 2.5 + Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * r + (Math.random()-0.5)*2;
            const z = Math.sin(angle) * r + (Math.random()-0.5)*2;

            // Explosion
            const exR = 30 + Math.random() * 50;
            const exTheta = Math.random() * Math.PI * 2;
            const exPhi = Math.acos(2 * Math.random() - 1);

            // Color Variation
            if (Math.random() > 0.2) particles.setColorAt(i, new THREE.Color(0xffd700)); 
            else particles.setColorAt(i, new THREE.Color(0xffffff)); 

            dummy.position.set(x, y - TREE_HEIGHT/2, z);
            dummy.updateMatrix();
            particles.setMatrixAt(i, dummy.matrix);

            particleData.push({
                treePos: new THREE.Vector3(x, y - TREE_HEIGHT/2, z),
                explodePos: new THREE.Vector3(exR * Math.sin(exPhi) * Math.cos(exTheta), exR * Math.sin(exPhi) * Math.sin(exTheta), exR * Math.cos(exPhi)),
                currentPos: new THREE.Vector3(x, y - TREE_HEIGHT/2, z)
            });
        }
        scene.add(particles);

        // 2. Ornaments (Metal + Glow)
        const ornamentGeo = new THREE.SphereGeometry(0.7, 32, 32);
        const ornamentMat = new THREE.MeshStandardMaterial({
            color: 0xffcc00, 
            metalness: 1.0, 
            roughness: 0.1, 
            emissive: 0xff8800, 
            emissiveIntensity: 1.5 // ‰∏≠Á≠âÂèëÂÖâ
        });
        const ornaments = new THREE.InstancedMesh(ornamentGeo, ornamentMat, ORNAMENT_COUNT);
        const ornamentData = [];

        for(let i=0; i<ORNAMENT_COUNT; i++){
            const y = Math.random() * (TREE_HEIGHT - 2);
            const r = (1 - y / TREE_HEIGHT) * TREE_RADIUS * 0.85;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;

            dummy.position.set(x, y - TREE_HEIGHT/2, z);
            dummy.updateMatrix();
            ornaments.setMatrixAt(i, dummy.matrix);
            ornaments.setColorAt(i, new THREE.Color(Math.random() > 0.4 ? 0xffd700 : 0xff0000));

            ornamentData.push({
                treePos: new THREE.Vector3(x, y - TREE_HEIGHT/2, z),
                explodePos: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
                currentPos: new THREE.Vector3(x, y - TREE_HEIGHT/2, z)
            });
        }
        scene.add(ornaments);

        // 3. Topper
        const topper = new THREE.Mesh(
            new THREE.OctahedronGeometry(2.5, 0),
            new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 1.0, roughness: 0.2, emissive: 0xffaa00, emissiveIntensity: 3.0 })
        );
        topper.position.set(0, TREE_HEIGHT/2 + 1, 0);
        scene.add(topper);

        // 4. Images (Pro Ratio Fix)
        const imageGroups = [];
        const textureLoader = new THREE.TextureLoader();
        const GALLERY_CENTER = new THREE.Vector3(0, 10, 45); 

        IMAGE_URLS.forEach((url) => {
            const group = new THREE.Group();

            // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂÖàÂàõÂª∫ÈªòËÆ§1x1ÁöÑÂπ≥Èù¢
            const geometry = new THREE.PlaneGeometry(1, 1);
            
            // Èôç‰ΩéÊùêË¥®È¢úËâ≤‰∫ÆÂ∫¶(0.8)ÔºåÈò≤Ê≠¢ÂõæÁâáÊú¨Ë∫´Ëøá‰∫ÆËß¶ÂèëBloom‰∫ßÁîüÂÖâÊôï
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0xcccccc, // Áï•ÂæÆÂèòÊöóÔºåÈÅøÂÖçËøáÊõù
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0 
            });
            const mesh = new THREE.Mesh(geometry, mat);

            // ËæπÊ°Ü
            const borderGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(1, 1));
            const borderMat = new THREE.LineBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0 });
            const border = new THREE.LineSegments(borderGeo, borderMat);
            
            group.add(mesh);
            group.add(border);
            
            // ÈªòËÆ§Âü∫Á°ÄÂ∞∫ÂØ∏
            group.userData = {
                explodePos: new THREE.Vector3((Math.random()-0.5)*90, (Math.random()-0.5)*60, (Math.random()-0.5)*40),
                mesh: mesh,
                border: border,
                baseScale: new THREE.Vector3(6, 6, 1) // ÈªòËÆ§Ê≠£ÊñπÂΩ¢ fallback
            };

            // ÂºÇÊ≠•Âä†ËΩΩÁ∫πÁêÜÂπ∂ËÆ°ÁÆóÊØî‰æã
            textureLoader.load(url, (tex) => {
                mat.map = tex;
                mat.needsUpdate = true;

                // ËÆ°ÁÆóÂÆΩÈ´òÊØî
                const aspect = tex.image.width / tex.image.height;
                let sx, sy;
                
                // ÈÄªËæëÔºöËÆ©ÊúÄÈïøËæπÁ≠â‰∫é6
                if (aspect >= 1) {
                    sx = 6;
                    sy = 6 / aspect;
                } else {
                    sy = 6;
                    sx = 6 * aspect;
                }
                
                // Â≠òÂÇ®ËÆ°ÁÆóÂ•ΩÁöÑÂü∫Á°ÄÊØî‰æã
                group.userData.baseScale.set(sx, sy, 1);
                
                // Êõ¥Êñ∞ËæπÊ°ÜÂΩ¢Áä∂‰ª•ÂåπÈÖçÂõæÁâáÊØî‰æã
                group.remove(border);
                const newBorderGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(1, 1)); // Geometry stays 1x1, scaled by group
                const newBorder = new THREE.LineSegments(newBorderGeo, borderMat);
                // ÂÆûÈôÖ‰∏äËæπÊ°Ü‰πü‰ºöË∑üÈöè group ÁöÑ scale Áº©ÊîæÔºåÊâÄ‰ª•‰∏çÈúÄË¶ÅÈáçÊñ∞Âª∫ geometryÔºåÂè™ÈúÄË¶ÅÁ°Æ‰øù group scale Ê≠£Á°Æ
                group.add(border); // Âä†ÂõûÊù•
            });

            group.scale.set(0,0,0);
            scene.add(group);
            imageGroups.push(group);
        });


        // --- LOGIC ---

        function updateLayout(targetState) {
            if (STATE.current === targetState) return;
            STATE.current = targetState;

            const arrows = document.querySelectorAll('.arrow');
            arrows.forEach(el => el.style.display = targetState === 'GALLERY' ? 'block' : 'none');

            const dur = 1.2;
            const bgState = (targetState === 'GALLERY') ? 'EXPLODED' : targetState;
            
            // Particles
            particleData.forEach(d => {
                const t = bgState === 'TREE' ? d.treePos : d.explodePos;
                gsap.to(d.currentPos, { x: t.x, y: t.y, z: t.z, duration: dur + Math.random(), ease: "power2.inOut" });
            });
            ornamentData.forEach(d => {
                const t = bgState === 'TREE' ? d.treePos : d.explodePos;
                gsap.to(d.currentPos, { x: t.x, y: t.y, z: t.z, duration: dur, ease: "power2.out" });
            });

            // Images
            imageGroups.forEach(group => {
                const m = group.userData.mesh;
                const b = group.userData.border;
                const baseS = group.userData.baseScale;

                if (targetState === 'TREE') {
                    gsap.to(group.scale, { x: 0, y: 0, z: 0, duration: 0.5 });
                    gsap.to(m.material, { opacity: 0, duration: 0.5 });
                    gsap.to(b.material, { opacity: 0, duration: 0.5 });
                    resetSelection(group);
                } 
                else if (targetState === 'EXPLODED') {
                    resetSelection(group);
                    const t = group.userData.explodePos;
                    gsap.to(group.position, { x: t.x, y: t.y, z: t.z, duration: dur });
                    // ‰ΩøÁî® BaseScale (ÂéüÂßãÊØî‰æã) ‰ΩÜÁº©Â∞è‰Ωú‰∏∫Áº©Áï•Âõæ
                    gsap.to(group.scale, { x: baseS.x, y: baseS.y, z: baseS.z, duration: dur }); 
                    gsap.to(group.rotation, { x: 0, y: 0, z: 0, duration: dur });
                    gsap.to(m.material, { opacity: 0.7, duration: dur });
                    gsap.to(b.material, { opacity: 0.5, duration: dur });
                }
                else if (targetState === 'GALLERY') {
                    if (group !== window.selectedGroup) {
                        const t = group.userData.explodePos;
                        gsap.to(group.position, { x: t.x, y: t.y, z: t.z, duration: dur });
                        gsap.to(group.scale, { x: baseS.x, y: baseS.y, z: baseS.z, duration: dur });
                        gsap.to(m.material, { opacity: 0.2, duration: dur }); 
                        gsap.to(b.material, { opacity: 0.1, duration: dur });
                    }
                }
            });

            if (targetState === 'TREE') {
                gsap.to(topper.scale, { x: 1, y: 1, z: 1, duration: 1 });
                gsap.to(camera.position, { x: CAM_DEFAULT_POS.x, y: CAM_DEFAULT_POS.y, z: CAM_DEFAULT_POS.z, duration: 1.5 });
            } else {
                gsap.to(topper.scale, { x: 0, y: 0, z: 0, duration: 0.5 });
            }

            if (targetState === 'GALLERY') {
                selectImage(STATE.galleryIndex);
            }
        }

        function selectImage(index) {
            if (window.selectedGroup) {
                const old = window.selectedGroup;
                const t = old.userData.explodePos;
                const baseS = old.userData.baseScale;
                gsap.to(old.position, { x: t.x, y: t.y, z: t.z, duration: 0.8 });
                gsap.to(old.scale, { x: baseS.x, y: baseS.y, z: baseS.z, duration: 0.8 });
                gsap.to(old.userData.mesh.material, { opacity: 0.2, duration: 0.8 });
            }

            STATE.galleryIndex = (index + imageGroups.length) % imageGroups.length;
            const targetGroup = imageGroups[STATE.galleryIndex];
            window.selectedGroup = targetGroup;

            const baseS = targetGroup.userData.baseScale;
            
            // Move to Center
            gsap.to(targetGroup.position, { x: GALLERY_CENTER.x, y: GALLERY_CENTER.y, z: GALLERY_CENTER.z, duration: 1.0, ease: "back.out(1.2)" });
            gsap.to(targetGroup.rotation, { x: 0, y: 0, z: 0, duration: 0.5 });
            
            // Scale Up (Keep Ratio) -> Multiply baseScale by 3.5
            gsap.to(targetGroup.scale, { x: baseS.x * 3.5, y: baseS.y * 3.5, z: 1, duration: 1.0 });
            
            gsap.to(targetGroup.userData.mesh.material, { opacity: 1.0, duration: 0.5 });
            gsap.to(targetGroup.userData.border.material, { opacity: 1.0, duration: 0.5 });
        }

        function resetSelection(group) {
            if(group === window.selectedGroup) window.selectedGroup = null;
        }

        function handleWave(currX) {
            const now = Date.now();
            if (now - STATE.lastWaveTime < 500) return; 
            const delta = currX - STATE.lastHandX;
            if (Math.abs(delta) > 0.03) {
                const dir = delta > 0 ? -1 : 1; 
                const btn = dir === 1 ? document.getElementById('next-btn') : document.getElementById('prev-btn');
                if(btn) { btn.classList.add('active'); setTimeout(()=>btn.classList.remove('active'), 200); }
                selectImage(STATE.galleryIndex + dir);
                STATE.lastWaveTime = now;
            }
        }

        // --- HANDS ---
        const videoElement = document.getElementById('input-video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        
        hands.onResults((results) => {
            document.getElementById('loading').style.display = 'none';

            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

            const lm = results.multiHandLandmarks[0];
            const currX = 1.0 - lm[0].x; 
            const currY = lm[0].y;
            STATE.handX = currX; STATE.handY = currY;

            let fingersUp = 0;
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            if (lm[4].x < lm[3].x && lm[5].x < lm[17].x) fingersUp++; else if (lm[4].x > lm[3].x && lm[5].x > lm[17].x) fingersUp++; 
            for (let i = 0; i < 4; i++) { if (lm[tips[i]].y < lm[pips[i]].y) fingersUp++; }

            const isEdge = currX < 0.05 || currX > 0.95 || currY > 0.95;

            // Interaction Logic (No changes needed, kept stable)
            if ((fingersUp === 0 || (fingersUp === 1 && lm[8].y > lm[6].y)) && !isEdge) {
                updateLayout('TREE');
            } 
            else if (fingersUp >= 4) {
                if (STATE.current === 'TREE') updateLayout('EXPLODED');
                else if (STATE.current === 'GALLERY') handleWave(currX);
            } 
            else if (fingersUp === 1 || fingersUp === 2) {
                if (STATE.current !== 'GALLERY') updateLayout('GALLERY');
                else handleWave(currX);
            }
            
            STATE.lastHandX = currX;
        });

        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 });
        cameraUtils.start();

        document.getElementById('prev-btn').addEventListener('click', () => selectImage(STATE.galleryIndex - 1));
        document.getElementById('next-btn').addEventListener('click', () => selectImage(STATE.galleryIndex + 1));

        // --- LOOP ---
        const clock = new THREE.Clock();
        const treeGroup = new THREE.Group();
        treeGroup.add(particles);
        treeGroup.add(ornaments);
        treeGroup.add(topper);
        scene.add(treeGroup);

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const d = particleData[i];
                dummy.position.copy(d.currentPos);
                // Èó™ÁÉÅÈÄªËæëÂ¢ûÂº∫
                const s = 1.0 + Math.sin(time * 10 + i) * 0.5; 
                dummy.scale.setScalar(s);
                if (STATE.current === 'TREE') dummy.rotation.y += 0.01;
                else dummy.position.y += Math.sin(time + i) * 0.01;
                dummy.updateMatrix();
                particles.setMatrixAt(i, dummy.matrix);
            }
            particles.instanceMatrix.needsUpdate = true;

            for (let i = 0; i < ORNAMENT_COUNT; i++) {
                const d = ornamentData[i];
                dummy.position.copy(d.currentPos);
                dummy.scale.setScalar(1);
                dummy.updateMatrix();
                ornaments.setMatrixAt(i, dummy.matrix);
            }
            ornaments.instanceMatrix.needsUpdate = true;

            if (STATE.current === 'TREE') {
                treeGroup.rotation.y = time * 0.15; 
            } else if (STATE.current === 'EXPLODED') {
                const tx = (STATE.handX - 0.5) * 12;
                const ty = (STATE.handY - 0.5) * 6;
                gsap.to(treeGroup.rotation, { y: tx * 0.2, x: ty * 0.1, duration: 1 });
            }

            topper.rotation.y += 0.02;
            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>