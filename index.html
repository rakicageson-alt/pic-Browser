<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Christmas Showroom Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Times New Roman', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
        
        .header { 
            position: absolute; top: 20px; width: 100%; text-align: center; 
            color: #d4af37; font-size: 2rem; letter-spacing: 5px; text-shadow: 0 0 30px #d4af37, 0 0 10px #ffffff;
            font-weight: bold; pointer-events: none;
        }

        #input-video { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: -1; }
        
        #loading { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-size: 1.5rem; transition: opacity 0.5s; z-index: 50; text-shadow: 0 0 10px black;
        }

        .arrow {
            position: absolute; top: 50%; transform: translateY(-50%);
            font-size: 6rem; color: rgba(255, 215, 0, 0.5); cursor: pointer;
            pointer-events: auto; user-select: none; transition: 0.3s;
            display: none; filter: drop-shadow(0 0 15px #d4af37);
        }
        .arrow:hover, .arrow.active { color: #fff; scale: 1.2; filter: drop-shadow(0 0 30px #d4af37); }
        #prev-btn { left: 30px; }
        #next-btn { right: 30px; }

        #gesture-hint {
            position: absolute; bottom: 20px; right: 20px;
            color: rgba(255,255,255,0.5); font-size: 14px; text-align: right;
            line-height: 1.6; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading">Adjusting Light Levels...</div>
    <div class="header">SHOW ROOM</div>
    
    <div id="ui-layer">
        <div id="prev-btn" class="arrow">‚Äπ</div>
        <div id="next-btn" class="arrow">‚Ä∫</div>
        <div id="gesture-hint">
            ‚úä Fist: Tree (Reset)<br>
            üñê Palm: Explode / Wave<br>
            ‚òù Index: Select Image
        </div>
    </div>

    <video id="input-video"></video>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        // --- CONFIG ---
        // ‰Ω†ÁöÑÂõæÁâáËÆæÁΩÆ
        const IMAGE_URLS = Array.from({ length: 7 }, (_, i) => `./${(i + 1).toString().padStart(2, '0')}.jpg`);

        const PARTICLE_COUNT = 3500;
        const ORNAMENT_COUNT = 250;
        const TREE_HEIGHT = 45;
        const TREE_RADIUS = 18;

        const STATE = {
            current: 'TREE', 
            handX: 0.5, handY: 0.5,
            galleryIndex: 0,
            lastHandX: 0.5, lastWaveTime: 0
        };

        // --- SCENE ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const CAM_DEFAULT_POS = new THREE.Vector3(0, 10, 65);
        camera.position.copy(CAM_DEFAULT_POS);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // ‰ΩøÁî®ÁéØÂ¢ÉË¥¥ÂõæÂÆûÁé∞ÈáëÂ±ûÂèçÂ∞Ñ
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        
        // ÈáçË¶ÅÔºöÂºÄÂêØËâ≤Ë∞ÉÊò†Â∞ÑÔºåÈò≤Ê≠¢È´ò‰∫ÆÊ∫¢Âá∫
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.9;
        container.appendChild(renderer.domElement);

        // --- BLOOM FIX (ÂÖ≥ÈîÆ‰øÆÊîπ) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        
        // 1. ÊèêÈ´òÈòàÂÄºÔºöÂè™ÊúâÈùûÂ∏∏‰∫ÆÁöÑ‰∏úË•ø(>0.9)Êâç‰ºöÂèëÂÖâÔºåÊôÆÈÄöÂõæÁâá(0-1.0)‰∏ç‰ºöÂèëÂÖâ
        bloomPass.threshold = 0.9; 
        bloomPass.strength = 1.2; 
        bloomPass.radius = 0.8;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambientLight);
        // ‰∏ªÂÖâÊ∫ê
        const mainLight = new THREE.PointLight(0xffd700, 5, 100);
        mainLight.position.set(10, 20, 20);
        scene.add(mainLight);

        // --- OBJECTS ---
        const dummy = new THREE.Object3D();
        const _color = new THREE.Color();

        // 1. HDR Particles (ÂèëÂÖâÁ≤íÂ≠ê)
        // ‰ΩøÁî® StandardÊùêË¥® + Emissive Êù•Á™ÅÁ†¥‰∫ÆÂ∫¶ÈòàÂÄº
        const particleGeo = new THREE.SphereGeometry(0.12, 4, 4);
        const particleMat = new THREE.MeshStandardMaterial({ 
            color: 0x000000, // Base color black
            emissive: 0xffd700, // Gold glow
            emissiveIntensity: 5.0, // Âº∫Â∫¶5.0ÔºåËøúË∂ÖÈòàÂÄº0.9ÔºåÊâÄ‰ª•‰ºöÂâßÁÉàÂèëÂÖâ
            roughness: 0.1,
            metalness: 1.0
        });
        const particles = new THREE.InstancedMesh(particleGeo, particleMat, PARTICLE_COUNT);
        const particleData = [];

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const y = Math.random() * TREE_HEIGHT;
            const r = (1 - y / TREE_HEIGHT) * TREE_RADIUS;
            const angle = y * 2.5 + Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * r + (Math.random()-0.5)*2;
            const z = Math.sin(angle) * r + (Math.random()-0.5)*2;

            // Explosion Logic
            const exR = 30 + Math.random() * 50;
            const exTheta = Math.random() * Math.PI * 2;
            const exPhi = Math.acos(2 * Math.random() - 1);

            // Color variation
            if (Math.random() > 0.2) particles.setColorAt(i, new THREE.Color(0xffd700)); 
            else particles.setColorAt(i, new THREE.Color(0xffffff)); 

            dummy.position.set(x, y - TREE_HEIGHT/2, z);
            dummy.updateMatrix();
            particles.setMatrixAt(i, dummy.matrix);

            particleData.push({
                treePos: new THREE.Vector3(x, y - TREE_HEIGHT/2, z),
                explodePos: new THREE.Vector3(exR * Math.sin(exPhi) * Math.cos(exTheta), exR * Math.sin(exPhi) * Math.sin(exTheta), exR * Math.cos(exPhi)),
                currentPos: new THREE.Vector3(x, y - TREE_HEIGHT/2, z)
            });
        }
        scene.add(particles);

        // 2. Ornaments (Metal Spheres)
        const ornamentGeo = new THREE.SphereGeometry(0.7, 32, 32);
        const ornamentMat = new THREE.MeshStandardMaterial({
            color: 0xffcc00, metalness: 1.0, roughness: 0.1, 
            emissive: 0xffaa00, emissiveIntensity: 2.0 // ‰∏≠Á≠âÂèëÂÖâ
        });
        const ornaments = new THREE.InstancedMesh(ornamentGeo, ornamentMat, ORNAMENT_COUNT);
        const ornamentData = [];

        for(let i=0; i<ORNAMENT_COUNT; i++){
            const y = Math.random() * (TREE_HEIGHT - 2);
            const r = (1 - y / TREE_HEIGHT) * TREE_RADIUS * 0.85;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;

            dummy.position.set(x, y - TREE_HEIGHT/2, z);
            dummy.updateMatrix();
            ornaments.setMatrixAt(i, dummy.matrix);
            ornaments.setColorAt(i, new THREE.Color(Math.random() > 0.4 ? 0xffd700 : 0xdd0000));

            ornamentData.push({
                treePos: new THREE.Vector3(x, y - TREE_HEIGHT/2, z),
                explodePos: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
                currentPos: new THREE.Vector3(x, y - TREE_HEIGHT/2, z)
            });
        }
        scene.add(ornaments);

        // 3. Topper
        const topper = new THREE.Mesh(
            new THREE.OctahedronGeometry(2.5, 0),
            new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 1.0, roughness: 0.2, emissive: 0xff8800, emissiveIntensity: 3.0 })
        );
        topper.position.set(0, TREE_HEIGHT/2 + 1, 0);
        scene.add(topper);

        // 4. Images
        const imageMeshes = [];
        const textureLoader = new THREE.TextureLoader();
        
        // Á°Æ‰øùÂõæÁâáÂú®Áõ∏Êú∫ÂâçÂêàÈÄÇÁöÑ‰ΩçÁΩÆ (Z=45)
        const GALLERY_CENTER = new THREE.Vector3(0, 10, 45); 

        IMAGE_URLS.forEach((url) => {
            const group = new THREE.Group();

            // Image Plane
            // ‰ΩøÁî® BasicMaterialÔºåÂÆÉ‰∏çÂèçÂÖâÔºå‰∏çÂèóÂÖâÁÖßÂΩ±ÂìçÔºå‰∏îÂÉèÁ¥†ÂÄº‰∏çË∂ÖËøá1.0ÔºåÊâÄ‰ª•‰∏ç‰ºöËß¶Âèë Bloom
            const mat = new THREE.MeshBasicMaterial({ 
                map: textureLoader.load(url), 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0 
            });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(6, 6), mat);
            
            // Border (Emissive frame) - ËæπÊ°ÜËÆ©ÂÆÉÂèëÂÖâ
            const borderGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(6.2, 6.2));
            const borderMat = new THREE.LineBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0 });
            const border = new THREE.LineSegments(borderGeo, borderMat);

            group.add(mesh);
            group.add(border);

            group.userData = {
                explodePos: new THREE.Vector3((Math.random()-0.5)*90, (Math.random()-0.5)*60, (Math.random()-0.5)*40),
                mesh: mesh,
                border: border
            };
            
            group.scale.set(0,0,0);
            scene.add(group);
            imageMeshes.push(group);
        });


        // --- LOGIC ---

        function updateLayout(targetState) {
            if (STATE.current === targetState) return;
            STATE.current = targetState;

            // UI
            const arrows = document.querySelectorAll('.arrow');
            arrows.forEach(el => el.style.display = targetState === 'GALLERY' ? 'block' : 'none');

            const dur = 1.2;
            const bgState = (targetState === 'GALLERY') ? 'EXPLODED' : targetState;
            
            // Particles
            particleData.forEach(d => {
                const t = bgState === 'TREE' ? d.treePos : d.explodePos;
                gsap.to(d.currentPos, { x: t.x, y: t.y, z: t.z, duration: dur + Math.random(), ease: "power2.inOut" });
            });
            ornamentData.forEach(d => {
                const t = bgState === 'TREE' ? d.treePos : d.explodePos;
                gsap.to(d.currentPos, { x: t.x, y: t.y, z: t.z, duration: dur, ease: "power2.out" });
            });

            // Images
            imageMeshes.forEach(group => {
                const m = group.userData.mesh;
                const b = group.userData.border;

                if (targetState === 'TREE') {
                    gsap.to(group.scale, { x: 0, y: 0, z: 0, duration: 0.5 });
                    gsap.to(m.material, { opacity: 0, duration: 0.5 });
                    gsap.to(b.material, { opacity: 0, duration: 0.5 });
                    resetSelection(group);
                } 
                else if (targetState === 'EXPLODED') {
                    resetSelection(group);
                    const t = group.userData.explodePos;
                    gsap.to(group.position, { x: t.x, y: t.y, z: t.z, duration: dur });
                    gsap.to(group.scale, { x: 1, y: 1, z: 1, duration: dur });
                    gsap.to(group.rotation, { x: 0, y: 0, z: 0, duration: dur });
                    gsap.to(m.material, { opacity: 0.7, duration: dur });
                    gsap.to(b.material, { opacity: 0.5, duration: dur });
                }
                else if (targetState === 'GALLERY') {
                    if (group !== window.selectedGroup) {
                        const t = group.userData.explodePos;
                        gsap.to(group.position, { x: t.x, y: t.y, z: t.z, duration: dur });
                        gsap.to(group.scale, { x: 1, y: 1, z: 1, duration: dur });
                        gsap.to(m.material, { opacity: 0.2, duration: dur }); // Dim others
                        gsap.to(b.material, { opacity: 0.1, duration: dur });
                    }
                }
            });

            // Topper & Camera
            if (targetState === 'TREE') {
                gsap.to(topper.scale, { x: 1, y: 1, z: 1, duration: 1 });
                gsap.to(camera.position, { x: CAM_DEFAULT_POS.x, y: CAM_DEFAULT_POS.y, z: CAM_DEFAULT_POS.z, duration: 1.5 });
            } else {
                gsap.to(topper.scale, { x: 0, y: 0, z: 0, duration: 0.5 });
            }

            if (targetState === 'GALLERY') {
                selectImage(STATE.galleryIndex);
            }
        }

        function selectImage(index) {
            if (window.selectedGroup) {
                const old = window.selectedGroup;
                const t = old.userData.explodePos;
                gsap.to(old.position, { x: t.x, y: t.y, z: t.z, duration: 0.8 });
                gsap.to(old.scale, { x: 1, y: 1, duration: 0.8 });
                gsap.to(old.userData.mesh.material, { opacity: 0.2, duration: 0.8 });
            }

            STATE.galleryIndex = (index + imageMeshes.length) % imageMeshes.length;
            const targetGroup = imageMeshes[STATE.galleryIndex];
            window.selectedGroup = targetGroup;

            // Move to Center
            gsap.to(targetGroup.position, { x: GALLERY_CENTER.x, y: GALLERY_CENTER.y, z: GALLERY_CENTER.z, duration: 1.0, ease: "back.out(1.2)" });
            gsap.to(targetGroup.rotation, { x: 0, y: 0, z: 0, duration: 0.5 });
            gsap.to(targetGroup.scale, { x: 3.5, y: 3.5, z: 3.5, duration: 1.0 });
            
            // Highlight
            gsap.to(targetGroup.userData.mesh.material, { opacity: 1.0, duration: 0.5 });
            gsap.to(targetGroup.userData.border.material, { opacity: 1.0, duration: 0.5 });
        }

        function resetSelection(group) {
            if(group === window.selectedGroup) window.selectedGroup = null;
        }

        function handleWave(currX) {
            const now = Date.now();
            if (now - STATE.lastWaveTime < 500) return; 
            const delta = currX - STATE.lastHandX;
            // Èôç‰ΩéÊå•ÊâãÁÅµÊïèÂ∫¶ÈòàÂÄºÔºåËÆ©ÂÆÉÊõ¥ÂÆπÊòìËß¶Âèë
            if (Math.abs(delta) > 0.03) {
                const dir = delta > 0 ? -1 : 1; 
                const btn = dir === 1 ? document.getElementById('next-btn') : document.getElementById('prev-btn');
                if(btn) { btn.classList.add('active'); setTimeout(()=>btn.classList.remove('active'), 200); }
                selectImage(STATE.galleryIndex + dir);
                STATE.lastWaveTime = now;
            }
        }

        // --- HANDS ---
        const videoElement = document.getElementById('input-video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        
        hands.onResults((results) => {
            document.getElementById('loading').style.display = 'none';

            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

            const lm = results.multiHandLandmarks[0];
            const currX = 1.0 - lm[0].x; 
            const currY = lm[0].y;
            STATE.handX = currX; STATE.handY = currY;

            let fingersUp = 0;
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            if (lm[4].x < lm[3].x && lm[5].x < lm[17].x) fingersUp++; else if (lm[4].x > lm[3].x && lm[5].x > lm[17].x) fingersUp++; 
            for (let i = 0; i < 4; i++) { if (lm[tips[i]].y < lm[pips[i]].y) fingersUp++; }

            const isEdge = currX < 0.05 || currX > 0.95 || currY > 0.95;

            // --- Ê†∏ÂøÉ‰øÆÂ§çÔºöÊâãÂäøÂÜ≤Á™ÅÈÄªËæë ---
            
            // 1. Êè°Êã≥ (Fist) -> ÂßãÁªàÂèØ‰ª•ÂõûÂà∞Âú£ËØûÊ†ëÊ®°Âºè
            if ((fingersUp === 0 || (fingersUp === 1 && lm[8].y > lm[6].y)) && !isEdge) {
                updateLayout('TREE');
            } 
            // 2. Âº†ÂºÄÊâãÊéå (Palm)
            else if (fingersUp >= 4) {
                if (STATE.current === 'TREE') {
                    // Â¶ÇÊûúÂú®Ê†ëÊ®°ÂºèÔºåÊâçÂÖÅËÆ∏ÁÇ∏ÂºÄ
                    updateLayout('EXPLODED');
                } else if (STATE.current === 'GALLERY') {
                    // Â¶ÇÊûúÂ∑≤ÁªèÂú®ÁúãÂõæÊ®°ÂºèÔºåÂøΩÁï•‚ÄúÁÇ∏ÂºÄ‚ÄùÊåá‰ª§ÔºåËΩ¨ËÄåÊ£ÄÊµãÊå•Êâã
                    handleWave(currX);
                }
                // Â¶ÇÊûúÂ∑≤ÁªèÊòØ EXPLODEDÔºå‰øùÊåÅÂç≥ÂèØ
            } 
            // 3. È£üÊåá (Index) -> ËøõÂÖ•ÁúãÂõæÊ®°Âºè
            else if (fingersUp === 1 || fingersUp === 2) {
                if (STATE.current !== 'GALLERY') updateLayout('GALLERY');
                else handleWave(currX);
            }
            
            STATE.lastHandX = currX;
        });

        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 });
        cameraUtils.start();

        document.getElementById('prev-btn').addEventListener('click', () => selectImage(STATE.galleryIndex - 1));
        document.getElementById('next-btn').addEventListener('click', () => selectImage(STATE.galleryIndex + 1));

        // --- LOOP ---
        const clock = new THREE.Clock();
        const treeGroup = new THREE.Group();
        treeGroup.add(particles);
        treeGroup.add(ornaments);
        treeGroup.add(topper);
        scene.add(treeGroup);

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const d = particleData[i];
                dummy.position.copy(d.currentPos);
                const s = 1.0 + Math.sin(time * 10 + i) * 0.5; 
                dummy.scale.setScalar(s);
                if (STATE.current === 'TREE') dummy.rotation.y += 0.01;
                else dummy.position.y += Math.sin(time + i) * 0.01;
                dummy.updateMatrix();
                particles.setMatrixAt(i, dummy.matrix);
            }
            particles.instanceMatrix.needsUpdate = true;

            for (let i = 0; i < ORNAMENT_COUNT; i++) {
                const d = ornamentData[i];
                dummy.position.copy(d.currentPos);
                dummy.scale.setScalar(1);
                dummy.updateMatrix();
                ornaments.setMatrixAt(i, dummy.matrix);
            }
            ornaments.instanceMatrix.needsUpdate = true;

            if (STATE.current === 'TREE') {
                treeGroup.rotation.y = time * 0.15; 
            } else if (STATE.current === 'EXPLODED') {
                const tx = (STATE.handX - 0.5) * 12;
                const ty = (STATE.handY - 0.5) * 6;
                gsap.to(treeGroup.rotation, { y: tx * 0.2, x: ty * 0.1, duration: 1 });
            }

            topper.rotation.y += 0.02;
            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>